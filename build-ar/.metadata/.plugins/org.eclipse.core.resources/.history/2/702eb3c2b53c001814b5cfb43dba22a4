#include <boost/thread.hpp>

#include "math.h"
#include <iostream>
#include <fstream>

//#include "Log4cppArm.hpp"
#include "Comm.h"
#include "robot/Geometry.h"
#include "chassis/can_socket.h"
#include "TransferDevice.h"
#include "interprocess/shared_pool.hpp"

#include "chassis/t20_can_driver.h"

#define LEN_MAX   102400
#define ID_181    0x181
#define ID_182    0x182
#define ID_183    0x183


t20_can_driver::t20_can_driver():list_speed_(1),ct_(0)
{

	b_run_ = false;
	port_ = "ttyS0";

	dangle_ = 0;
	reduction_ratio_ = 0.021;
	pTransDevice_ = 0;
	angle_zero_ = -1.0;
	alive_count_ = 0;

	k_para.load_para();
	k_angle_para.load_para();
	k_fork_para.load_para();

	can_data_type_ = CAN_TYPE::USB_BOX;
	can_port_ = "ttyUSB1";

    set_rpm_ = 0;
    rpm_Kp_ = 0.2;
    rpm_Ki_ = 0.02;
    rpm_last_error_ = 0;
    rpm_current_error_ = 0;
    rpm_error_ = 0;
    extern_dio_.id_[0] = 0;
    forkpos_offset_ = 0;

    Angle_Kp_ = 1;
    Angle_Ki_ = 0.2;
    Angle_Kd_ = 0.15;
    Ki_max_ = 10.0;
    Angle_err_ = 0;
    Angle_err_last_ = 0;
    Angle_err_sum_ = 0;
}

t20_can_driver::~t20_can_driver()
{


}

void t20_can_driver::setPara( std::string name ,std::string value )
{
	if (name == "port")
	{
		port_ = value;
		std::cout<<"port_:"<<value<<std::endl;
	}else if(name == "can_type")
	{
		int itype = CAN_TYPE::USB_LD;
		cComm::ConvertToNum(itype,value);
		can_data_type_ = (CAN_TYPE)itype;
		std::cout<<"can_type:"<<itype<<std::endl;

	}else if(name == "can_port")
	{
		can_port_ = value;
		std::cout<<"can_port_:"<<value<<std::endl;

	}else if(name == "ratio"){
		cComm::ConvertToNum(reduction_ratio_,value);
		cComm::RangeIt(reduction_ratio_,(F32)0,(F32)200.0);
		std::cout<<"reduction_ratio_:"<<reduction_ratio_<<std::endl;
	}else if(name == "angle_zero"){
		cComm::ConvertToNum(angle_zero_,value);
		cComm::RangeIt(angle_zero_,(F32)-5,(F32)5.0);
		std::cout<<"angle_zero:"<<angle_zero_<<std::endl;
	}else if(name == "fnc_code"){
		boost::mutex::scoped_lock lock(mu_action);
		cComm::ConvertToNum(fnc_code_,value);
		if(fnc_code_ == 0){
			hasTask = false;
		}else if(fnc_code_<4){
			hasTask = true;
			ct_ = 0;
			std::cout<<"Chassis receive fork task!fnc_code:"<<fnc_code_<<std::endl;
		}

	}else if(name == "para"){
		boost::mutex::scoped_lock lock(mu_action);
		S32 newvalue = 0;
		cComm::ConvertToNum(newvalue,value);
		if(newvalue>2300){
			newvalue =2300;
		}else if(newvalue<90){
			newvalue = 90;
		}
		para_= k_fork_para.trans_fork(newvalue);
		forkpos_offset_ = newvalue - para_;
		std::cout<<"newvalue: "<<(int)newvalue<<" after trans: "<<(int)para_<<std::endl;
	}else if(name == "status"){
		boost::mutex::scoped_lock lock(mu_action);
		cComm::ConvertToNum(dio_fork_status_,value);
	}else
	{
		std::cout<<"err para:"<<name<<" value:"<<value<<std::endl;
	}

}

void t20_can_driver::setRPMOri( int id,F32 v )
{
	//set left driver speed
	F32 speed = 0 ;  //0.1 counts/s

	{

		boost::mutex::scoped_lock lock(mu_feedback_);
		if( alive_count_ > 0){
			alive_count_--;
		}else{
			//std::cout<<"t20 can failed!! set rpm 0!"<<std::endl;
			wheel_speed_rpm_ = 0;
			v = 0;
		}
	}


	if (id == 0)
	{

		U8 i=0;
		F32 speed=0;

		speed = v*10;//10rpm

		U8 read_speed[10]={0};

		SetSpeed_ = (S16)speed;
		//std::cout<<"setv="<<SetSpeed_<<"  seta="<<SetAangle_<<std::endl;

		half_MB_10_.id_=0x00;
		half_MB_10_.Cmd_ = 0x10;
		half_MB_10_.reg_addr_ = 0x0031;
		half_MB_10_.reg_num_ = 0x0003;
		half_MB_10_.bit_num = 0x0007;
		half_MB_10_.Fun_code_= (U8)fnc_code_;
		half_MB_10_.Send_10_data.push_back(SetSpeed_);
		half_MB_10_.Send_10_data.push_back(SetAangle_);
		half_MB_10_.Send_10_data.push_back(SetUpDown_);

		t20_dio::ModBus_10_Send(half_MB_10_, Send_10_, num_10_);
		SendData(Send_10_, num_10_);
		//std::string str = cComm::ByteToHexString(Send_10_,num_10_);
		//std::cout<<"send:"<<str<<std::endl;

		if(!ModBus_Read(read_speed, 8)){
			std::cout<<"DIO ERR!"<<std::endl;
		}

		half_MB_10_.Send_10_data.clear();

	}else{

		std::cout<<"set RPM err! id:"<<id<<std::endl;
	}



	
}
void t20_can_driver::setRPM( int id,F32 v )
{
	//set left driver speed
	F32 speed = 0 ;  //0.1 counts/s

	{

		boost::mutex::scoped_lock lock(mu_feedback_);
		if( alive_count_ > 0){
			alive_count_--;
		}else{
			//std::cout<<"t20 can failed!! set rpm 0!"<<std::endl;
			wheel_speed_rpm_ = 0;
			v = 0;
		}
	}


	if (id == 0)
	{
//		long long t=  test_dt_.GetTime();
//	   std::cout<<" dt :"<<t/1000<<std::endl;
//	   test_dt_.End();
//		test_dt_ .Begin();

		U8 i=0;
		F32 speed=0;

		set_rpm_ = v;

		//std::cout<<"setv="<<std::dec<<set_rpm_<<"  seta="<<std::dec<<SetAangle_<<std::endl;
		//PID
		SDI dio;
        {
			boost::mutex::scoped_lock lock(mu_dio_);
			dio = extern_dio_;
		}
		if(dio.di_[0] == 1){
				rpm_error_ = 0;
		}else
		{
			if(v!=0){
				rpm_current_error_ = v- wheel_speed_rpm_;
				if(fabs(rpm_current_error_)>30)
					rpm_current_error_ = 30*(rpm_current_error_/fabs(rpm_current_error_));
				//std::cout<<"v:"<<v<<"  current_error_: "<<rpm_current_error_;
				if(fabs(rpm_current_error_)>3){
					rpm_error_  +=  rpm_current_error_;
					if(fabs(rpm_error_)>1500){
						rpm_error_ = 1500*(rpm_error_/fabs(rpm_error_));
					}
				}else{
					rpm_error_ = 0;
				}
				set_rpm_ = v+ rpm_Kp_*(rpm_current_error_)+rpm_Ki_*(rpm_error_);
				//std::cout<<" set_rpm: "<<set_rpm_<<std::endl;
				rpm_last_error_  = rpm_current_error_;
			}else{
				rpm_error_ = 0;
			}

		}


		F32 trpm = k_para.trans_rpm(set_rpm_);
		//F32 trpm=v;x
		speed = trpm*10;//10rpm

		U8 read_speed[10]={0};

		SetSpeed_ = (S16)speed;
		//std::cout<<"v ="<<std::dec<<SetSpeed_<<"  a ="<<std::dec<<SetAangle_<<std::endl;
		SetUpDown_ = (U16)para_;
		half_MB_10_.id_=0x00;
		half_MB_10_.Cmd_ = 0x10;
		half_MB_10_.reg_addr_ = 0x0031;
		half_MB_10_.reg_num_ = 0x0003;
		half_MB_10_.bit_num = 0x0007;
		boost::mutex::scoped_lock lock(mu_action);
		if((hasTask == true)&&(-1 != para_)){
			half_MB_10_.Fun_code_=(U8)fnc_code_;
			//std::cout<<"Set fnc_code:"<<fnc_code_<<std::endl;
		}
		else {
			half_MB_10_.Fun_code_ = 0;
		}
		//half_MB_10_.Fun_code_=(U8)fnc_code_;
		half_MB_10_.Send_10_data.push_back(SetSpeed_);
		half_MB_10_.Send_10_data.push_back(SetAangle_);
		half_MB_10_.Send_10_data.push_back(SetUpDown_);

		t20_dio::ModBus_10_Send(half_MB_10_, Send_10_, num_10_);
		SendData(Send_10_, num_10_);
		//std::string str = cComm::ByteToHexString(Send_10_,num_10_);
		//std::cout<<"Chassis send: "<<str<<std::endl;

		if(ModBus_Read(read_speed, 8)){
			if(hasTask == true){
				fork_status_ = read_speed[5];
				short fork_pos = 0;
				if(fnc_code_ ==3){
					fork_pos = read_speed[3]*256+read_speed[2];
					//std::cout<<"fork_status:"<<(int)fork_status_<<" pos: "<<(short)fork_pos<<std::endl;
				}
				if(fork_status_ == 1)     //  0: IDEL   1:finished   2: Working
				{
					dio_fork_status_ = 1;
				}
				else if(fork_status_ == 2)
				{
					//isWorking = true;
					dio_fork_status_ = 0;
				}else{
					dio_fork_status_ = 0;
				}

				SFork_state current_status;
				current_status.fnc_code_ = fnc_code_;
				current_status.para_   =  fork_pos+forkpos_offset_;
				current_status.current_status_ = dio_fork_status_;
				shared_pool::Publish(shared_pool::name(),"get_fork_status",current_status);
				if(dio_fork_status_){
					hasTask = false;
					dio_fork_status_ = 0;
					para_ = -1;
					std::cout<<"Chassis  Finish fork task ! dio_fork_status_:"<<dio_fork_status_<<"  pos:"<<(int)fork_pos<<std::endl;
				}
			}
		}else{
			std::cout<<"DIO ERR!"<<std::endl;
		}

		half_MB_10_.Send_10_data.clear();

	}else{

		std::cout<<"set RPM err! id:"<<id<<std::endl;
	}


//	if(hasTask == true)
//	{
//		if(ct_ %10 == 0){
//			SLEEP(10);
//			ReadTruckStatus();
//			SFork_state current_status;
//			current_status.fnc_code_ = fnc_code_;
//			current_status.para_   =  para_;
//			current_status.dio_fork_status_ = dio_fork_status_;
//			shared_pool::Publish(shared_pool::name(),"get_fork_status",current_status);
//			if(dio_fork_status_){
//				hasTask = false;
//				//isWorking = false;
//				dio_fork_status_ = 0;
//				std::cout<<"Chassis  Finish fork task ! dio_fork_status_:"<<dio_fork_status_<<std::endl;
//			}
//		}
//	}

}
F32 t20_can_driver::getSpeed( int id )
{
	if (id == 0)
	{
		boost::mutex::scoped_lock lock(mu_feedback_);
		return wheel_speed_rpm_;
	}else{
		std::cout<<"get RPM err! id:"<<id<<std::endl;
		return 0;
	}
}

F32 t20_can_driver::getDiffAngle( int id )
{
	
	F64 dt = dt_.GetTime();
	dt /= 1000000;
	dt_.Begin();


	if(id == 0){

//		ST20_Can_data can_data = data_.get_data(reduction_ratio_);
//		c_action_wheel_speed_ = can_data.wheel_speed_rpm_;
//		c_action_wheel_angle_ = Deg2Rad(can_data.wheel_angle_deg_);

		//std::cout<<"c_action_wheel_speed_:"<<c_action_wheel_speed_<<std::endl;
		//std::cout<<" c_action_wheel_angle_:"<<c_action_wheel_angle_<<std::endl;
		F32 rpm = 0;
		{

			if( list_speed_.get(rpm) ){
				boost::mutex::scoped_lock lock(mu_feedback_);
				wheel_speed_rpm_ = rpm;
				alive_count_ = 30;
			}
//			boost::mutex::scoped_lock lock(mu_feedback_);
//			wheel_speed_rpm_ = rpm;
//			alive_count_ = 50;
			//std::cout<<"wheel_speed_rpm_:"<<wheel_speed_rpm_<<std::endl;
		}

		if (dt > 1.0)
		{
			return dangle_;
		}else{
			//RPM / 60 = rps
			//rps * dt

			dangle_ = rpm / 60 *  dt;

			return dangle_;
		}
	}
	return 0;
}


void t20_can_driver::close_driver()
{
	b_run_ = false;
	SLEEP(300);

	if (pTransDevice_)
	{
		cConnPara ConnPara;
		pTransDevice_->GetPara(ConnPara);
		cTransferDevice::DelInstance(ConnPara);
		pTransDevice_ = 0;
	}

}

bool t20_can_driver::open_transfer_device()
{
//	test();
	close_driver();

	switch(can_data_type_){
	case CAN_TYPE::ON_BOARD:
		std::cout<<"ON_BOARD Can!"<<std::endl;
		can_socket::init();
		break;
	case CAN_TYPE::USB_LD:
		std::cout<<"USB_LD Can:"<<can_port_<<std::endl;
		usb_ld_.init_driver(can_port_);
		break;
	case CAN_TYPE::USB_BOX:
		canalyst2_.init_driver();
		break;
	default:
		break;

	}

	cConnPara conn_para;
	conn_para.m_iType = cConnPara::SERIALPORT ;
	conn_para.setDeviceName(port_);
	conn_para.nBaud = 115200;
	conn_para.chParity = 'N';
	conn_para.nDataBits = 8;
	conn_para.nStopBits = 1;

	pTransDevice_ = cTransferDevice::GetInstance(conn_para);

	//if (sport_->Init(port_,115200))
	U32 wait = 20;
	if (pTransDevice_ )
	{
		while(wait--){

			if (pTransDevice_->m_Status.IsOpen())
			{
				std::cout<<"orientalmotor open 115200 ok"<<std::endl;
				return true;
			}

			SLEEP(100);
		}


	}
	return false;


}

bool t20_can_driver::init_driver()
{
	boost::thread th( boost::bind( &t20_can_driver::th_read,this ) );
	fnc_code_ = 0;
	para_ = 0;
	dio_fork_status_ = 0;
	hasTask = false;
	isWorking = false;
	return true;
}

void t20_can_driver::setAngle( int id,F32 rad_angle )
{
	if( 0 == id ){
		//std::cout<<"t20_can_driver::setAngle 0:"<<rad_angle<<std::endl;
		F32 deg = 0;
		F32 rad = rad_angle;
		//std::cout<<"a="<<rad_angle<<std::endl;

//		std::cin>>rad;
//		rad = Deg2Rad(rad);

		rad = Angle_PID(rad);

		deg = k_angle_para.trans_angle(rad);
		deg = Rad2Deg(deg);

		SetAangle_ = (S16)(deg*10);

		std::cout<<"setAngle:"<<Rad2Deg(rad_angle)<<"  curr_angle:"<<wheel_angle_deg_<<std::endl;
	}else{
		std::cout<<"t20_can_driver::setAngle set err id:"<<id<<std::endl;
	}
	
}
void t20_can_driver::setAngleOri( int id,F32 rad_angle )
{
	if( 0 == id ){
		//std::cout<<"t20_can_driver::setAngle 0:"<<rad_angle<<std::endl;
		F32 deg = 0;
		//std::cout<<"a="<<rad_angle<<std::endl;

		deg = Rad2Deg(rad_angle);

		SetAangle_ = (S16)(deg*10);

	}else{
		std::cout<<"t20_can_driver::setAngle set err id:"<<id<<std::endl;
	}

}
F32 t20_can_driver::getAngle( int id )
{
	if ( id == 0 )
	{
		boost::mutex::scoped_lock lock(mu_feedback_);
		//std::cout<<"wheel_angle_deg_:"<<wheel_angle_deg_<<std::endl;
		return Deg2Rad( wheel_angle_deg_ );
	}
	else if(id == 1)
	{
		F32 fork_pos=0;
		fork_pos = half_MB_10_.Fun_code_;

		return fork_pos;
	}
	else
	{
		std::cout<<"t20_can_driver::getAngle err id:"<<id<<std::endl;
		return 0;
	}
	
}

F32 t20_can_driver::Angle_PID(F32 Set_Angle)
{
	F32 Angle=0;

	Set_Angle = Rad2Deg(Set_Angle);
	Angle_err_ = Set_Angle - wheel_angle_deg_;

	if(fabs(Angle_err_)<20.0)
	{
		if(fabs(Angle_err_sum_) < Ki_max_)
		{
			Angle_err_sum_ += Angle_err_;
		}
		Angle = Angle_Kp_*Angle_err_ + Angle_Ki_*Angle_err_sum_ + Angle_Kd_*(Angle_err_-Angle_err_last_);
		Angle_err_last_ = Angle_err_;
	}
	else
	{
		Angle_err_sum_ = 0;
		Angle_err_last_ = Angle_err_;
	}
	Angle += Set_Angle;
	return Deg2Rad(Angle);
}

void t20_can_driver::ReadTruckStatus(void)
{
	half_MB_03_.id_       =0x00;
	half_MB_03_.Cmd_	  =0x03;
	half_MB_03_.reg_addr_ =0x0033;
	half_MB_03_.reg_num_  =0x0001;

	t20_dio::ModBus_03_Send(half_MB_03_,Send_03_);
	SendData(Send_03_, 8);

	U8 read_status[7]={0};
	if(!ModBus_Read(read_status, 7)){
		std::cout<<"READ STATUS ERR!"<<std::endl;
		return ;
	}
	//std::string str = cComm::ByteToHexString(read_status,7);
	//std::cout<<"read TruckStatus:"<<str<<std::endl;
	boost::mutex::scoped_lock lock(mu_st);
	is_cmd_mode_ = (read_status[4]>>0)&0x01;
	//fork_status_ = (read_status[4]>>1)&0x01;
	is_forward_  = (read_status[4]>>1)&0x01;
	is_tiller_   = (read_status[4]>>2)&0x01;
	is_guard_    = (read_status[4]>>3)&0x01;
	is_pedal_    = (read_status[4]>>4)&0x01;
	is_stand_    = (read_status[4]>>5)&0x01;
	fork_status_ = read_status[3];
	std::cout<<"fork_status:"<<(int)fork_status_<<std::endl;
	if(fork_status_ == 1)     //  0: IDEL   1:finished   2: Working
	{
		dio_fork_status_ = 1;
	}
	else if(fork_status_ == 2)
	{
		//isWorking = true;
		dio_fork_status_ = 0;
	}

	else
		dio_fork_status_ = 0;
//	std::cout<<"is_cmd_mode_d:"<<is_cmd_mode_<<std::endl;
//	std::cout<<"fork_status_: "<<fork_status_<<std::endl;
//	std::cout<<"is_forward_:  "<<is_forward_<<std::endl;
//	std::cout<<"is_tiller_:   "<<is_tiller_<<std::endl;
//	std::cout<<"is_guard_:    "<<is_guard_<<std::endl;
//	std::cout<<"is_pedal_:    "<<is_pedal_<<std::endl;
//	std::cout<<"is_stand_:    "<<is_stand_<<std::endl;

}

S32 t20_can_driver::ReadL16Fork(void)
{
	S32 Fork_Vol=0;

	half_MB_03_.id_       =0x00;
	half_MB_03_.Cmd_	  =0x03;
	half_MB_03_.reg_addr_ =0x0034;
	half_MB_03_.reg_num_  =0x0001;

	t20_dio::ModBus_03_Send(half_MB_03_,Send_03_);
	SendData(Send_03_, 8);
	//std::string str = cComm::ByteToHexString(Send_03_,8);
	//std::cout<<"send TruckStatus:"<<str<<std::endl;
	U8 read_fork[7]={0};
	if(!ModBus_Read(read_fork, 7)){
		std::cout<<"READ FORK ERR!"<<std::endl;
		return 0;
	}
	Fork_Vol = (0x00<<24)|(0x00<<16)|(read_fork[4]<<8)|(read_fork[3]<<0);
	//std::string str = cComm::ByteToHexString(read_fork,7);
	//std::cout<<"read TruckStatus:"<<str<<std::endl;
	//std::cout<<"read hight=:"<<Fork_Vol<<std::endl;
	return Fork_Vol;
}
void t20_can_driver::setfork(U32 fun_code_ri, S32 fork_hight_ri)
{
	F32 tfork=0;
	tfork = k_fork_para.trans_fork(fork_hight_ri);
	SetUpDown_ = tfork;
	std::cout<<"set hight=:"<<fork_hight_ri<<"  tfork="<<tfork<<"send hight="<<SetUpDown_<<std::endl;
	fnc_code_ = fun_code_ri;

}

void t20_can_driver::th_read()
{
	b_run_ = true;
	U8 data_r[LEN_MAX] = {0};
	int rlen = 0;

	std::cout<<"t20_can_driver::th_read!"<<std::endl;

	while(b_run_){

		std::vector<can_frame> PDO_Receive;

		switch(can_data_type_){

		case CAN_TYPE::ON_BOARD:
		{

			if(can_socket::ReadData(PDO_Receive)){


			}else{
				std::cout<<"can_socket::ReadData err:"<<std::endl;
			}
			break;
		}

		case CAN_TYPE::USB_LD:
		{
			if(usb_ld_.ReadData(PDO_Receive)){


			}else{
				std::cout<<"USB_LD::ReadData err:"<<std::endl;
			}
			break;
		}
		case CAN_TYPE::USB_BOX:
		{
			if(canalyst2_.ReadData(PDO_Receive)){


			}else{
				std::cout<<"USB_BOX::ReadData err:"<<std::endl;
			}
			break;
		}
		default:
			break;

		}

		std::vector<can_frame>::iterator it = PDO_Receive.begin();

		for( ; it != PDO_Receive.end() ; ++it ){
			can_frame frame(*it);

			if(frame.can_id==ID_181)
			{
				parse_181(frame.data);
			}else if(frame.can_id==ID_183)
			{
				parse_183(frame.data);
			}
		}


	}
}
void t20_can_driver::parse_181(U8* Data8)
{
//	std::cout<<"id:0x181"<<std::endl;
//	std::string str = cComm::ByteToHexString(Data8,8);
//	std::cout<<" data:"<<str<<std::endl;

	if( (0xff != Data8[2]) || ( 0xff != Data8[3] ) ){
		return;
	}

	S16 s16_speed;
	U8* p = (U8*)&s16_speed;
	*p = Data8[0];
	*(p + 1) = Data8[1];

	F32 rpm = 0;
	rpm = -s16_speed;
	rpm *= reduction_ratio_;
	//std::cout<<"reduction_ratio_:"<<reduction_ratio_<<std::endl;
	list_speed_.put(rpm);
//	std::cout<<"rpm:"<<rpm<<std::endl;
//	boost::mutex::scoped_lock lock(mu_feedback_);
//	feedback_data_.wheel_speed_rpm_ = -s16_speed;
//	if( abs(s16_speed) > 0){
//		std::cout<<"wheel speed rpm:"<<s16_speed<<std::endl;
//		std::cout<<"speed_rpm:"<<feedback_data_.wheel_speed_rpm_<<std::endl;
//	}
	//std::cout<<"wheel_speed_rpm_:"<<rpm<<std::endl;
}
void t20_can_driver::parse_183(U8* Data8)
{
//	std::cout<<"id:0x183"<<std::endl;
//	std::string str = cComm::ByteToHexString(Data8,8);
//	std::cout<<" data:"<<str<<std::endl;

	S16 s16_angle;
	U8* p = (U8*)&s16_angle;
	*p = Data8[0];
	*(p + 1) = Data8[1];
	if(s16_angle == -1){
		std::cout<<"drop data!"<<std::endl;
		return;
	}

	boost::mutex::scoped_lock lock(mu_feedback_);

	wheel_angle_deg_ = s16_angle;
	//std::cout<<"183 wheel_angle_deg_:"<<wheel_angle_deg_<<std::endl;
	wheel_angle_deg_ = wheel_angle_deg_ / 10;
	//std::cout<<"wheel_angle_deg_:"<<wheel_angle_deg_<<std::endl;
	wheel_angle_deg_ -= angle_zero_;

	//std::cout<<"wheel_angle_deg_:"<<wheel_angle_deg_<<std::endl;

}
void t20_can_driver::SendData( U8* s_data,U16 len )
{
	if (pTransDevice_)
	{
		pTransDevice_->WriteData(s_data,len);

	}
}

void t20_can_driver::ReadData(  U8* r_data,int &len,const int &need  )
{

	if (pTransDevice_)
		{
			pTransDevice_->ReadData(r_data, len,need,100);

			//std::cout<<"need:"<<need<<" res:"<<len<<std::endl;
		}

}
bool t20_can_driver::ModBus_Read(U8* read_data, const int &len)
{
	S32 len_=0;
	ReadData(read_data, len_, len);
	if(  (len_ > 1) )
	{
		if((*(read_data+1) > 0x80 )){
			return false;
		}else{
			return true;
		}
	}
	return false;
}

