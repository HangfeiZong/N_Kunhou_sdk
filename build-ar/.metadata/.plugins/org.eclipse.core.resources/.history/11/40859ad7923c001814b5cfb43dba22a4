#include "math.h"

#include "Comm.h"
#include "chassis/driver_base.h"
#include "chassis/chassis_forklift_kh.h"
#define MIN_ANGLE (0.05235833)//( 3.0 / 180.0 * 3.1415)

Chassis_forklift_kh::Chassis_forklift_kh():wheel_a_dia_(0.230),D_(1.39),L_(0.0),wheel_f_dia_(0.08)
{

	vx_ = 0;
	vy_ = 0;
	th_ = 0;
	Angle_ = 0;

	motion_type_ = (Motion_type::FORK_STEER | Motion_type::SINGLE);
}

Chassis_forklift_kh::~Chassis_forklift_kh()
{
	
}

void Chassis_forklift_kh::getOdomInBaseLink( F32 &dx,F32 &dy, F32 &th )
{
	F32 action_wheel_percent = driver_->getDiffAngle(0);
	F32 action_wheel_th = driver_->getAngle(0);
	Angle_ = action_wheel_th;

	//std::cout<<"Angle="<<Angle_<<std::endl;
	F32 dL = (F32)(wheel_a_dia_ * M_PI ) * action_wheel_percent ; 

	F32 da = dL / D_ * sin(action_wheel_th);
	
	if ( fabs( action_wheel_th ) < MIN_ANGLE )
	{
		dx = dL;
		dy = 0;
		th = 0;

	}else if( fabs( fabs(action_wheel_th) - M_PI/2 ) < MIN_ANGLE){

		dx = 0;
		dy = 0;
		th = da;

	}else{

		th = da;
		F32 r = D_ / tan(action_wheel_th) + L_;
		dx = r * sin( da );
		dy = r * ( 1 - cos( da ));

	}

	dt_.End();

	F32 time = dt_.GetTime();
	time = time / 1e6;
	
	if (time < 2.0)
	{
		vx_ = dx / time;
		vy_ = dy / time;
		th_ = th / time;
	}else{
		vx_ = 0;
		vy_ = 0;
		th_ = 0;
	}

	dt_.Begin();
}
void Chassis_forklift_kh::getOdomSpeed(F32 &vx,F32 &vy, F32 &th){

	vx = vx_;
	vy = vy_;
	th = th_;
	
}
F32 Chassis_forklift_kh::ASpeed2RPM( F32 speed )
{
	// wheel turn angle = wheel speed / perimeter
	// * 60 = RPM
	F32 RPM = speed / ( M_PI * wheel_a_dia_) * 60;
	return RPM;
}
void Chassis_forklift_kh::resolution(F32 &speed,F32 &angle,const F32& Vx,const F32& W){

	//no rotation
	if ( fabs( W ) < 0.005)
	{
		speed = Vx;
		angle = 0;
		return ;
	}
	//only rotation
	else if ( fabs(Vx) < 0.005  )
	{
		if (W < 0)
		{
			angle = -M_PI / 2;
		}else{
			angle = M_PI / 2;
		}
		speed = fabs( W * D_ );
		speed = speed*sin(fabs(Angle_));
		return ;
	}

	F32 Or = Vx / W;

	if (  fabs(Or) < 0.005 )
	{
		return;
	}
//	speed = sqrt( D_*D_  + (Or - L_)*(Or - L_)) * Vx / Or ;
//	angle = atan2( D_ , Or - L_);

	//bug fix for atan2

	if( (Or - L_) < 0 ){

		angle = atan2( -D_ , -(Or - L_));
		speed = -sqrt( D_*D_  + (Or - L_)*(Or - L_)) * Vx / Or ;
		speed = Vx - (speed-Vx)*cos(angle - Angle_);
		//speed = Vx;

	}else{
		angle = atan2( D_ , Or - L_);
		speed = sqrt( D_*D_  + (Or - L_)*(Or - L_)) * Vx / Or ;
		speed = Vx + (speed-Vx)*cos(angle - Angle_);
		//speed = Vx;
	}


	if (angle > (M_PI / 2))
	{
		angle = M_PI / 2;
	}else if(angle < -(M_PI / 2)){
		angle = -M_PI / 2;
	}

}



void Chassis_forklift_kh::setOdomSpeed( F32 vx, F32 vy, F32 vw )
{
	F32 speed_action = 0;
	F32 angle_action = 0;

	//std::cout<<"vx:"<<vx<<"  vw:"<<vw<<std::endl;

	resolution(speed_action,angle_action,vx,vw);

	speed_action = ASpeed2RPM(speed_action);
	//std::cout<<"speed:"<<speed_action<<" set angle:"<<angle_action<<std::endl;
	//std::cout<<"VX:"<<vx<<"  speed:"<<speed_action<<"  VW:"<<vw<<"  set angle:"<<(angle_action/M_PI*180)<<std::endl;

	//std::cin>>angle_action;
	driver_->setAngle(0,angle_action);
	driver_->setRPM(0,speed_action);

	//std::cout<<"vx:"<<std::setw(10)<<vx<<"  vw:"<<std::setw(10)<<vw<<"  speed_action:"<<std::setw(10)<<speed_action<<"  angle:"<<std::setw(10)<<angle_action<<std::endl;
}

void Chassis_forklift_kh::setPara( std::string name , std::string value )
{
	if(name == "adia"){
		cComm::ConvertToNum(wheel_a_dia_,value);
		cComm::RangeIt(wheel_a_dia_,F32(0.0),F32(1.0));
		std::cout<<"wheel_a_dia_:"<<wheel_a_dia_<<std::endl;
	}else if(name == "D"){
		cComm::ConvertToNum(D_,value);
		cComm::RangeIt(D_,F32(-5.0),F32(5.0));
		std::cout<<"D_:"<<D_<<std::endl;

	}else if(name == "L"){
		cComm::ConvertToNum(L_,value);
		cComm::RangeIt(L_,F32(-3.0),F32(3.0));
		std::cout<<"L_:"<<L_<<std::endl;
	}else{
		std::cout<<"err name:"<<name<<" para:"<<value<<std::endl;
	}	
	
}





