#include "math.h"

#include "Comm.h"
#include "chassis/my_driver.h"

#include "chassis/chassis_forklift_ex.h"
#define MIN_ANGLE (0.05235833)//( 3.0 / 180.0 * 3.1415)

Chassis_forklift_ex::Chassis_forklift_ex():wheel_a_dia_(0.230),D_(1.39),D1_(1.39),D2_(1.35),D3_(1.41),L_(0.0),wheel_f_dia_(0.08)
{
	Angle_ = 0;
	vx_ = 0;
	vy_ = 0;
	th_ = 0;
	D_ = D1_;
	is_fork_up_ = true;
	is_forward_ = true;

	motion_type_ = (Motion_type::FORK_STEER | Motion_type::SINGLE);
}

Chassis_forklift_ex::~Chassis_forklift_ex()
{
	
}

void Chassis_forklift_ex::getOdomInBaseLink( F32 &dx,F32 &dy, F32 &th )
{
	F32 action_wheel_percent = driver_->getDiffAngle(0);
	F32 action_wheel_th = driver_->getAngle(0);
	Angle_ = action_wheel_th;
	if(driver_->getAngle(1) == 1)
	{
		is_fork_up_ = true;
	}
	else if(driver_->getAngle(1) == 2)
	{
		is_fork_up_ = false;
	}
//	is_fork_up_ = true;

	F32 dL = (F32)(wheel_a_dia_ * M_PI ) * action_wheel_percent ; 
	//F32 dl = dL * cos(th);
	//std::cout<<"dL:"<<dL<<std::endl;

	F32 da = dL / D_ * sin(action_wheel_th);
	
	if ( fabs( action_wheel_th ) < MIN_ANGLE )
	{
		dx = dL;
		dy = 0;
		th = 0;

	}else if( fabs( fabs(action_wheel_th) - M_PI/2 ) < MIN_ANGLE){

		dx = 0;
		dy = 0;
		th = da;

	}else{

		th = da;
		F32 r = D_ / tan(action_wheel_th) + L_;
		dx = r * sin( da );
		dy = r * ( 1 - cos( da ));

	}

	dt_.End();

	F32 time = dt_.GetTime();
	time = time / 1e6;
	
	if (time < 2.0)
	{
		vx_ = dx / time;
		vy_ = dy / time;
		th_ = th / time;
	}else{
		vx_ = 0;
		vy_ = 0;
		th_ = 0;
	}

	dt_.Begin();
}
void Chassis_forklift_ex::getOdomSpeed(F32 &vx,F32 &vy, F32 &th){

	vx = vx_;
	vy = vy_;
	th = th_;
	
}
F32 Chassis_forklift_ex::ASpeed2RPM( F32 speed )
{
	// wheel turn angle = wheel speed / perimeter
	// * 60 = RPM
	F32 RPM = speed / ( M_PI * wheel_a_dia_) * 60;
	return RPM;
}
void Chassis_forklift_ex::resolution(F32 &speed,F32 &angle,const F32& Vx,const F32& W){
	//no rotation
	if ( fabs( W ) < 0.005)
	{
		speed = Vx;
		angle = 0;
		return ;
	}
	//only rotation
	else if ( fabs(Vx) < 0.005  )
	{
		if (W < 0)
		{
			angle = -M_PI / 2;
		}else{
			angle = M_PI / 2;
		}
		speed = fabs( W * D_ );
		speed = speed-speed*cos(Angle_);
		return ;
	}

	F32 Or = Vx / W;

	if (  fabs(Or) < 0.005 )
	{
		return;
	}
//	speed = sqrt( D_*D_  + (Or - L_)*(Or - L_)) * Vx / Or ;
//	angle = atan2( D_ , Or - L_);

	//bug fix for atan2
	if( (Or - L_) < 0 ){

//		angle = atan2( -D_ , -(Or - L_));
//		speed = -sqrt( D_*D_  + (Or - L_)*(Or - L_)) * Vx / Or ;

		angle = atan2( -D_ , -(Or - L_));
		speed = -sqrt( D_*D_  + (Or - L_)*(Or - L_)) * Vx / Or ;
		speed = Vx + (speed-Vx)*cos(angle - Angle_);
		//speed = Vx;

	}else{

//		angle = atan2( D_ , Or - L_);
//		speed = sqrt( D_*D_  + (Or - L_)*(Or - L_)) * Vx / Or ;

		angle = atan2( D_ , Or - L_);
		speed = sqrt( D_*D_  + (Or - L_)*(Or - L_)) * Vx / Or ;
		speed = Vx + (speed-Vx)*cos(angle - Angle_);
		//speed = Vx;
	}

	if (angle > (M_PI / 2))
	{
		angle = M_PI / 2;
	}else if(angle < -(M_PI / 2)){
		angle = -M_PI / 2;
	}

}

void Chassis_forklift_ex::setOdomSpeed( F32 vx, F32 vy, F32 vw )
{
	F32 speed_action = 0;
	F32 angle_action = 0;

	if(vx >= 0)
	{
		is_forward_ = true;
	}else{
		is_forward_ = false;
	}
	if(is_forward_){
		D_ = D1_;
	}else if(!is_forward_ & is_fork_up_)
	{
		D_ = D2_;
	}else if(!is_forward_ & !is_fork_up_)
	{
		D_ = D3_;
	}
	//std::cout<<"vx:"<<vx<<"  vw:"<<vw<<std::endl;

	resolution(speed_action,angle_action,vx,vw);
	D_ = D1_;

	speed_action = ASpeed2RPM(speed_action);
	//std::cout<<"vx:"<<speed_action<<"  vw:"<<angle_action<<std::endl;

	driver_->setAngle(0,angle_action);
	driver_->setRPM(0,speed_action);

	//std::cout<<"vx:"<<std::setw(10)<<vx<<"  vw:"<<std::setw(10)<<vw<<"  speed_action:"<<std::setw(10)<<speed_action<<"  angle:"<<std::setw(10)<<angle_action<<std::endl;
}

void Chassis_forklift_ex::setPara( std::string name , std::string value )
{
	if(name == "adia"){
		cComm::ConvertToNum(wheel_a_dia_,value);
		cComm::RangeIt(wheel_a_dia_,F32(0.0),F32(1.0));
		std::cout<<"wheel_a_dia_:"<<wheel_a_dia_<<std::endl;
	}else if(name == "D1"){
		cComm::ConvertToNum(D1_,value);
		cComm::RangeIt(D1_,F32(-5.0),F32(5.0));
		std::cout<<"D1_:"<<D1_<<std::endl;
	}else if(name == "D2"){
		cComm::ConvertToNum(D2_,value);
		cComm::RangeIt(D2_,F32(-5.0),F32(5.0));
		std::cout<<"D2_:"<<D2_<<std::endl;
	}else if(name == "D3"){
		cComm::ConvertToNum(D3_,value);
		cComm::RangeIt(D3_,F32(-5.0),F32(5.0));
		std::cout<<"D3_:"<<D3_<<std::endl;
	}else if(name == "L"){
		cComm::ConvertToNum(L_,value);
		cComm::RangeIt(L_,F32(-3.0),F32(3.0));
		std::cout<<"L_:"<<L_<<std::endl;
	}else{
		std::cout<<"err name:"<<name<<" para:"<<value<<std::endl;
	}	
	
}





