/***************************************************************************************************
* File name:   roto_control.h
* Description:   
* Version:      0.0.1
* History: 
* (1) Author:   wanghongtao
*     Date:     2015-11-25
*     Operate:  Create
*     Version:  0.0.1
* Others: 
***************************************************************************************************/
#include <cmath>
#include <boost/asio.hpp>
#include <boost/date_time/posix_time/posix_time.hpp>
#include <iostream>
#include "my_tf.h"
#include "Geometry.h"
#include "roto_control.h"
#include "mapserver/MapPath.h"
#include "mapserver/MapServer.h"
#include "Log4cppArm.hpp"


roto_control::roto_control():
R_(1.5)
// ,pre_head_(0.5)
// ,go_straight_dy_(0.1)
,out_of_line_(0.5)
,close_to_path_(0)
,angle_diff_(0)
,max_vx_(0.2)
,min_vx_(0.1)
,max_inplace_vw_(1.0)
,min_inplace_vw_(0.1)
,line_control_(false)
,stop_distance_(0)
,stop_angle_diff_(1)
,reduce_speed1_(0.3)
,reduce_speed2_(0.15)
{
	stop_angle_diff_ = Deg2Rad(stop_angle_diff_);
	out_of_target_angle_ = 60;
	out_of_target_angle_ = Deg2Rad(out_of_target_angle_);
	inplace_rotation_angle_ = Deg2Rad(67);
	inplace_rotation_pid_p_ = 1;

	prohibit_map_ = CREATE_SHARED_GMAP(PROHIBIT_MAP);
}


roto_control::~roto_control()
{

}
void roto_control::init(const F32 &R){
	R_ = fabs(R);
// 	pre_head_ = pre_head;
// 
// 	go_straight_dy_ = R_ - sqrt( R_ * R_ - pre_head_ * pre_head_ );
	out_of_line_ = R_;


}
void roto_control::set_out_of_target( const F32 &angle ){
	out_of_target_angle_ = Deg2Rad(angle);
}
void roto_control::set_inplace_rotation_angle( const F32 &angle ){
	inplace_rotation_angle_ = Deg2Rad(angle);
}
void roto_control::set_inplace_rotation_pid_p( const F32 &p ){
	inplace_rotation_pid_p_ = p;
}
void roto_control::set_local_path_pre_length(const F32& pre_len,const F32 &pre_ext){
	local_path_pre_length_ = pre_len + pre_ext;
	local_path_pre_count_ = ( local_path_pre_length_ ) / 0.05 + 1;
}

void roto_control::set_speed_limit(const F32 speed_limit){

	buf_speed_limit_.put(speed_limit);
}
void roto_control::set_max_vx(const F32 max_vx){
	max_vx_ = max_vx;
}

void roto_control::set_min_vx(const F32 min_vx){
	min_vx_ = min_vx;
}
void roto_control::set_inplace_max_vw(const F32 max_vw){
	max_inplace_vw_ = max_vw;
}
void roto_control::set_inplace_min_vw(const F32 min_vw){
	min_inplace_vw_ = min_vw;
}
void roto_control::set_reduce_speed1(const F32 &speed){
	reduce_speed1_ = speed;
}
void roto_control::set_reduce_speed2(const F32 &speed){
	reduce_speed2_ = speed;
}
bool roto_control::get_ex_speed_ctl(F32 &curent_speed){

	prohibit_map_->lock();

	S8 prohibit_cost = 0;
	U32 gx = 0;
	U32 gy = 0;
	prohibit_map_->getgtid( gx , gy , prohibit_cost);

	prohibit_map_->unlock();
	//printf("getTaskSpeed  cost  : %d\n",prohibit_cost);
	//std::cout<<"prohibit_cost:"<<int(prohibit_cost)<<std::endl;
	//stop
	if (   ( prohibit_cost < 0 ) || (( prohibit_cost >= 64) != 0) || (( prohibit_cost == 4) != 0))
	{
		//std::cout<<"curent_speed: speed = 0"<<std::endl;
		curent_speed = 0;
		return false;
	}else{
		//reduce 1 0.3m/s
		if( prohibit_cost & 0x01 ){

			if( curent_speed > reduce_speed1_ ){
				curent_speed = reduce_speed1_;
			}else if( curent_speed < -reduce_speed1_ ){
				curent_speed = -reduce_speed1_;
			}
			//std::cout<<"curent_speed: reduce1 speed = "<<curent_speed<<std::endl;
		}
		//reduce 1 0.15m/ss
		if( prohibit_cost & 0x02 ){
			if( curent_speed > reduce_speed2_ ){
				curent_speed = reduce_speed2_;
			}else if( curent_speed < -reduce_speed2_ ){
				curent_speed = -reduce_speed2_;
			}
			//std::cout<<"curent_speed: reduce2 speed = "<<curent_speed<<std::endl;
		}
	}
	return true;
}
F32 roto_control::get_target_vx(run_path &path){


	F32 target_vx;

	SOdomSpeed current_speed;
	path.get_current_speed(current_speed);
	target_vx = current_speed.vx_;
	//set path radious
	R_ = current_speed.vw_;

	close_to_path_ =  Dis_p2p(robot_pos_.x_,robot_pos_.y_,current_speed.x_,current_speed.y_);
	angle_diff_ = VecPosition::angle_diff(robot_pos_.th_ ,current_speed.th_);


	if( close_to_path_ > 0.5){
		//std::cout<<"far from path! speed down to 80%."<<std::endl;
		target_vx = target_vx*0.8;
	}
//	if( fabs( angle_diff_ ) > Deg2Rad(30) ){
//		std::cout<<"target angle diff large! speed down to 80%."<<std::endl;
//		target_vx = target_vx*0.8;
//	}
	
	return target_vx;
}
void roto_control::max_min_vx(F32 &target_vx){
	if( target_vx > 0 ){
		target_vx = cComm::Min(max_vx_,target_vx);
		target_vx = cComm::Max(min_vx_,target_vx);
	}else if( target_vx < 0 ){
		target_vx = cComm::Max(-max_vx_,target_vx);
		target_vx = cComm::Min(-min_vx_,target_vx);
	}
}
//target_pos is real pos of the path
//return pos is tmp target pos look ahead
SPos roto_control::get_target_pos(SPos &target_pos,run_path &path, F32 local_path_pre_length){

	SPos target_pos_new = target_pos;
	path.get_target_pos(target_pos,local_path_pre_count_);
	
	if( path.get_on_line() ){
		//last path no far from the target


		F32 dis = Dis_p2p(robot_pos_.x_,robot_pos_.y_,target_pos.x_,target_pos.y_);
		if( path.is_stop_path() ){

			F32 pre = para_.stop_pre_ahead_;

			if (local_path_pre_length < 0)
			{
				pre = -para_.stop_pre_ahead_;
			}
			VecPosition V_new_target(  pre , Rad2Deg(target_pos.th_) , POLAR);
			V_new_target += VecPosition(target_pos.x_,target_pos.y_);


			target_pos_new.x_ = V_new_target.getX();
			target_pos_new.y_ = V_new_target.getY();
			target_pos_new.th_ = target_pos.th_;
		}else{
			if(dis < (fabs( local_path_pre_length ))){
				dis =  fabs(local_path_pre_length ) - dis;
				if (local_path_pre_length < 0)
				{
					dis = -dis;
				}
				VecPosition V_new_target( dis , Rad2Deg(target_pos.th_) , POLAR);
				V_new_target += VecPosition(target_pos.x_,target_pos.y_);


				target_pos_new.x_ = V_new_target.getX();
				target_pos_new.y_ = V_new_target.getY();
				target_pos_new.th_ = target_pos.th_;
			}

		}

	}

	return target_pos_new;
}
bool roto_control::stopping( SSpeed &speed , F32 fdt, SOdomSpeed odom_speed , run_path &path, SPos robot_pos){

	speed.vy_ = 0;
	speed.vw_ = 0;

	if (check_out_of_target(robot_pos,path,speed.vx_))
	{
		return true;
	}

 	stop_distance_ = Dis_p2p(robot_pos.x_,robot_pos.y_,final_target_pos_.x_,final_target_pos_.y_);
 	//f_stop_acc_ =  (speed.vx_*speed.vx_ ) / (stop_distance_ * 2);
	//F32 f_stop_time = stop_distance_ * 2 / speed.vx_;
 	//std::cout<<"f_stop_acc_:"<<f_stop_acc_<<" fdt:"<<fdt<<std::endl;
	if( stop_distance_ > 1e-6 ){
		//Uniform deceleration motion
		// t = 2d /v  ; a = -(v*v)/2d;

		F32 stop_acc = fabs(f_stop_acc_) * fdt ;
		//std::cout<<"dt stop_speed:"<<stop_acc<<std::endl;

		if( stop_acc > fabs(speed.vx_) ){
			//stop_acc = fabs(speed.vx_) - 0.01;
			stop_acc = fabs(speed.vx_);
		}
	
		if( speed.vx_ > 0 ){
			speed.vx_ = speed.vx_ - stop_acc;
		}else{
			speed.vx_ = speed.vx_ + stop_acc;
		}
	}
// 	if( stop_distance_ < 0.01){
// 		speed.vx_ = 0;
// 	}
	std::cout<<"stop speed vx:"<<speed.vx_<<std::endl;
	//if ( fabs(speed.vx_) < 0.005 )
	if( (stop_distance_ < 0.01) || (fabs(speed.vx_) < 0.01))
	{
		speed.vx_ = 0;

		F32 traget_angle = path.get_final_target_angle();
		traget_angle = VecPosition::angle_diff( traget_angle , robot_pos.th_ );
		if(fabs(traget_angle) < stop_angle_diff_){
			return true;
		}else{
			speed.vy_ = 0;
			speed.vw_ = traget_angle * para_.inplace_rotation_pid_p_;
			//std::cout<<"final pos th:"<<final_target_pos_.th_<<" robot th:"<<robot_pos.th_<<std::endl;
			//std::cout<<"speed.vw_:"<<speed.vw_<<std::endl;
			speed.vw_ = max_min_w(speed.vw_);
		}

	}
	return false;

}
F32 roto_control::max_min_w(const F32 & vw){

	F32 w = vw;

	if( vw < 0){
		if( fabs(vw) < min_inplace_vw_){
			w = -min_inplace_vw_;
		}else if( fabs(vw) > max_inplace_vw_ ){
			w = -max_inplace_vw_;
		}
	}else{
		if( fabs(vw) < min_inplace_vw_){
			w = min_inplace_vw_;
		}else if( fabs(vw) > max_inplace_vw_ ){
			w = max_inplace_vw_;
		}
	}
	return w;
}
bool roto_control::check_out_of_target(const SPos &robot_pos, run_path &path,const F32 target_speed){

	VecPosition vtarget( final_target_pos_.x_ , final_target_pos_.y_ );
	VecPosition vrobot( robot_pos.x_ , robot_pos.y_ );
	vrobot -= vtarget;
	
	F32 tar_angle = final_target_pos_.th_;
	if (target_speed < 0)
	{
		tar_angle  = VecPosition::normalizeAngleRad(tar_angle + M_PI);
	}

	F32 angdiff = VecPosition::angle_diff( Deg2Rad( vrobot.getDirection()) , tar_angle  );

	if( fabs(angdiff) < out_of_target_angle_){
		std::cout<<"out_of_target angle diff :"<<angdiff<<std::endl;
		return true;
	}
	
	
	VecPosition vpath( pos_on_path_.x_ , pos_on_path_.y_ );
	vpath -= vtarget;

	

	if( vrobot.getMagnitude() > ( vpath.getMagnitude()*3 ) ){
		std::cout<<"out_of_target dis :"<<vrobot.getMagnitude()<<std::endl;
		std::cout<<"current path dis:"<<( vpath.getMagnitude()*2 )<<std::endl;
		return true;
	}


	return false;

}
SPos roto_control::extern_pos(SPos target_pos , F32 pre_dis){

	VecPosition V_new_target(  pre_dis , Rad2Deg(target_pos.th_) , POLAR);
	V_new_target += VecPosition(target_pos.x_,target_pos.y_);


	target_pos.x_ = V_new_target.getX();
	target_pos.y_ = V_new_target.getY();

	return target_pos;
}
SPos roto_control::get_target_pos( SPos &target_pos, run_path &path, const move_ment_para &para ,const F32 &target_speed ){

	SPos target_pos_new;
	if( path.get_on_line() ){
		
		F32 pre_dis = path.get_line_target_pos(target_pos,para,target_speed);
		//std::cout<<"prd_dis:"<<pre_dis<<std::endl;
		F32 dis = Dis_p2p(robot_pos_.x_,robot_pos_.y_,target_pos.x_,target_pos.y_);
		dis =  pre_dis  - dis;
		if(dis < 0){
			dis = 0;
		}
//		F32 dis = 0.2;
		if(target_speed < 0){
			dis = -dis;
		}
		target_pos_new = extern_pos(target_pos,dis);

//		if (target_speed < 0)
//		{
//			pre_dis = -pre_dis;
//		}
//		VecPosition V_new_target(  pre_dis , Rad2Deg(target_pos.th_) , POLAR);
//		V_new_target += VecPosition(target_pos.x_,target_pos.y_);
//
//
//		target_pos_new.x_ = V_new_target.getX();
//		target_pos_new.y_ = V_new_target.getY();
//		target_pos_new.th_ = target_pos.th_;

	}else{
		F32 pre_dis = path.get_arc_target_pos(target_pos,para);
		VecPosition vtarget(target_pos.x_,target_pos.y_);
		VecPosition vrobot(robot_pos_.x_,robot_pos_.y_);
		Line ln_target = Line::makeLineFromPositionAndAngle(vtarget,Rad2Deg(target_pos.th_));
		VecPosition vtdrop = ln_target.getPointOnLineClosestTo(vrobot);
		VecPosition vhead = vtarget - vtdrop;
		VecPosition vdis = vtdrop - vrobot;
		
		F32 f_head_dis = vdis.getMagnitude() - vhead.getMagnitude() ;
		
		if ( f_head_dis < 0 ){
			f_head_dis = 0;
		}else{
			if (target_speed < 0)
			{
				f_head_dis = -f_head_dis;
			}
		}
		target_pos_new = extern_pos(target_pos,f_head_dis);
	}
	return target_pos_new;
}
roto_control::CONTROL_STATUS roto_control::cal_speed( SSpeed &speed , run_path &path , SPos robot_pos,move_ment_para para){

	robot_pos_ = robot_pos;
	para_ = para;

	//1 b_line_ is set hear
	path.create_local_path(para_.go_stop_model_dis_,para_.go_next_path_dis_);
	pos_on_path_ = path.get_current_pos_on_path();
	show_pos_.clear();
	set_show_pos(pos_on_path_);


	//2 get target speed vx
	F32 target_speed = get_target_vx(path);
	//extern speed control : 1 pause 2 reduce1 3 reduce2
	if( !get_ex_speed_ctl( target_speed )){
		speed.vx_ = 0;
		speed.vy_ = 0;
		speed.vw_ = 0;
		return CTL_OBSTACLE_STOP;
	}
	max_min_vx(target_speed);


	//3 cal pre head : hight speed with far ahead
	// para_.local_path_pre_length_ default 0.3
//	if( path.is_last_path() ){
//		std::cout<<"last path"<<std::endl;
//		set_local_path_pre_length ( para_.stop_pre_ahead_ , 0);
//
//	}else{
//		F32 f_pre_head_dis = fabs(target_speed) * 2;
//		set_local_path_pre_length ( para_.local_path_pre_length_ , f_pre_head_dis);
//	}
//
//	SPos local_target_pos;
//	if (target_speed < 0)
//	{
//		local_target_pos = get_target_pos(final_target_pos_,path,-local_path_pre_length_);
//	}else{
//		local_target_pos = get_target_pos(final_target_pos_,path,local_path_pre_length_);
//	}
	SPos local_target_pos;
	local_target_pos = get_target_pos(final_target_pos_,path,para_,target_speed);
	set_show_pos(final_target_pos_);

	//3 check if end of path ,then got to stop
	if( path.is_end_of_path( stop_distance_ , robot_pos , final_target_pos_ , para_.go_stop_model_dis_ ) ){
		//Uniform deceleration motion
		// t = 2d /v  ; a = -(v*v)/2d;
		f_stop_acc_ =  (speed.vx_*speed.vx_ ) / (stop_distance_ * 2);

		std::cout<<"roto_control::cal_speed close to target f_stop_acc_:"<<f_stop_acc_<<std::endl;
		return CTL_STOP;
	}
	//set_show_pos(local_target_pos);
	
	//4 check run out of target 
	if(check_out_of_target( robot_pos , path , target_speed )){
		return CTL_OUT_OF_TARGET;
	}
	publish_pos();

	//5 cricle control speed algorithm
	return circle_clt(speed.vx_,speed.vw_ , target_speed , robot_pos , local_target_pos , path.get_on_line() ,path.limit_rotation());

}
//void show_local_path{
	// 	std::vector<SOdomSpeed>::iterator ii1 = path.local_path_.begin();
	// 	for (; ii1 != path.local_path_.end() ; ++ii1)
	// 	{
	// 		SPos path_pos;
	// 		path_pos.x_ = ii1->x_;
	// 		path_pos.y_ = ii1->y_;
	// 		path_pos.th_ = ii1->th_;
	// 		set_show_pos(path_pos);
	// 	}
	// 	ii1 = path.local_path2_.begin();
	// 	for (; ii1 != path.local_path2_.end() ; ++ii1)
	// 	{
	// 		SPos path_pos;
	// 		path_pos.x_ = ii1->x_;
	// 		path_pos.y_ = ii1->y_;
	// 		path_pos.th_ = ii1->th_;
	// 		set_show_pos(path_pos);
	// 	}

//}

roto_control::CONTROL_STATUS roto_control::circle_clt(F32 &line_speed ,F32 &angle_speed,const F32 &Vx ,const SPos &robot_pos,  const SPos &target_pos, bool b_line, bool b_limit_rotation){

//	set_show_pos(target_pos);

	line_speed = 0;
	angle_speed = 0;

//	std::cout<<"set current pos x:"<<robot_pos.x_<<" y:"<<robot_pos.y_<<" th:"<<robot_pos.th_<<std::endl;


	//1 current robot pos
	VecPosition V_current_pos(robot_pos.x_,robot_pos.y_);

	//2 target pos
	VecPosition V_target_pos(target_pos.x_,target_pos.y_);

	//3 rotation pos
	VecPosition V_rotation( R_ ,Rad2Deg(target_pos.th_), POLAR);
	V_rotation.rotate(-90);
	//V_rotation = V_target_pos + V_rotation;

	//4 target line
	Line ln_tmp_target = Line::makeLineFromPositionAndAngle(V_target_pos,V_rotation.getDirection() );

	//5 current pos to target pos
	VecPosition V_current_target;
	V_current_target = V_target_pos - V_current_pos;

	//6 mid line pos
	VecPosition V_mid_line_pos = V_current_target / 2;
	V_mid_line_pos += V_current_pos ;
	//std::cout<<"mid line pos:"<<V_mid_line_pos.getX()<<" y:"<<V_mid_line_pos.getY()<<std::endl;

	//7 mid line angle
	VecPosition V_mid_line_angle = V_current_target;
	V_mid_line_angle.rotate(-90);
	//std::cout<<"mid line angle:"<<V_mid_line_angle.getDirection()<<std::endl;

	//8 mid line
	Line ln_mid_line = Line::makeLineFromPositionAndAngle(V_mid_line_pos,V_mid_line_angle.getDirection() );

	//9 rotation pos
	F32 current_R = R_;

	F32 target_angle = target_pos.th_;
	VecPosition V_rotation_pos;
	if(ln_mid_line.getIntersection(ln_tmp_target,V_rotation_pos)){

		//	std::cout<<"rotation pos:"<<V_rotation_pos.getX()<<" y:"<<V_rotation_pos.getY()<<std::endl;

		//10 current_R
		VecPosition V_rotation_R = V_current_pos - V_rotation_pos;

		current_R = V_rotation_R.getMagnitude();


		VecPosition V_rotation_target = V_target_pos - V_rotation_pos;
		F32 angle = VecPosition::IntersectionAngle(V_rotation_target,V_rotation_R);
		if(angle*Vx < 0){
			current_R = -current_R;
		}
		//std::cout<<"V_rotation_R:"<<current_R<<std::endl;

		//11 target angle
		VecPosition V_target_angle = V_rotation_pos - V_current_pos;
		if(angle*Vx < 0){
			V_target_angle.rotate(90);
		}else{
			V_target_angle.rotate(-90);
		}

		target_angle = V_target_angle.getDirection();
		target_angle = Deg2Rad(target_angle);
	}else{
//		std::cout<<"no intersecton !!!!!!!!!!"<<std::endl;
//		std::cout<<"set current pos x:"<<robot_pos.x_<<" y:"<<robot_pos.y_<<" th:"<<robot_pos.th_<<std::endl;
//		std::cout<<"set target_pos pos x:"<<target_pos.x_<<" y:"<<target_pos.y_<<" th:"<<target_pos.th_<<std::endl;
	}

	

	//std::cout<<"target angle:"<<target_angle<<std::endl;
	

	SPos t;
	t.x_ = V_rotation_pos.getX();
	t.y_ = V_rotation_pos.getY();
	t.th_ = target_angle;
	//set_show_pos(t);

	t = robot_pos;
	t.th_ = target_angle;
	//set_show_pos(t);

 	F32 circle_w = 0;
 
 	if(fabs(current_R) > 1e-6) {
 		circle_w = Vx / current_R;
 	}
 //	std::cout<<"Vx:"<<Vx<<" current_R:"<<current_R<<std::endl;
 	
	F32 target_w = VecPosition::angle_diff( target_angle , robot_pos.th_ );
//
//	std::cout<<"target_w:"<<target_w<<std::endl;
	if( fabs(target_w) > inplace_rotation_angle_ ){
		std::cout<<"target_angle:"<<target_angle<<" robot_pos.th_:"<<robot_pos.th_<<std::endl;
		std::cout<<"inplace roation set speed Vx=0 : target_w w:"<<target_w<<std::endl;
		line_speed = 0;
		angle_speed = max_min_w( target_w );
		return CONTROL_STATUS::CTL_RUN;
	}else{
		line_speed = Vx;
	}

// 	if( fabs(current_R) < local_path_pre_length_){
// 		//std::cout<<"rotation ratio is small target Vx:"<<line_speed<<" target_w w:"<<target_w<<std::endl;
// 		target_w = max_min_w(target_w);
// 	}

// 	std::cout<<"final target w:"<<target_w<<std::endl;
// 	std::cout<<"rotaton w:"<<circle_w<<std::endl;

	if (!b_line)
	{
		//std::cout<<"rotaton w:"<<circle_w<<std::endl;
		std::cout<<"  target_w:"<<target_w<<"  rotaton_w:"<<circle_w<<std::endl;
		angle_speed = circle_w + target_w;
	}else{
		angle_speed = target_w;
		std::cout<<"  1target_w:"<<target_w<<"  1rotaton_w:"<<circle_w<<std::endl;
		//when last path will limit rotation
		if( b_limit_rotation ){
			angle_speed = circle_w + target_w;
			std::cout<<"limit rotation!"<<std::endl;
			if( fabs( circle_w ) > 0.1){
				if( (angle_speed * circle_w) < 0){
					angle_speed = 0;
					std::cout<<"different target w!"<<std::endl;
				}
			}
		}

	}
	
	//angle_speed =  target_w;


	return CONTROL_STATUS::CTL_RUN;
}


void roto_control::publish_pos()
{
	pub_.pwsize_ = show_pos_.size() ;
	int i = 0;
	std::list<SOdomSpeed>::iterator it = show_pos_.begin();

	for ( ; it != show_pos_.end() ; ++it )
	{
		pub_.data_w_[i].x = it->x_;
		pub_.data_w_[i].y = it->y_;
		pub_.data_w_[i].th = it->th_;
		pub_.data_w_[i++].aw = it->vx_;
		if(i >= 8192){
			break;
		}
	}
	show_pos_.clear();
	shared_pool::Publish(shared_pool::name(),"particles",pub_);
}

void roto_control::set_show_pos( const SPos &pos )
{
	if(show_pos_.size() >= 8192){
		std::cout<<"show pos err! max size: 8192!!"<<std::endl;
		return;
	}
	SOdomSpeed opos;
	memset(&opos,0,sizeof(SOdomSpeed));
	opos.x_ = pos.x_;
	opos.y_ = pos.y_;
	opos.th_ = pos.th_;
	show_pos_.push_back(opos);
}

